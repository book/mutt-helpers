#!/usr/bin/env perl
use strict;
use warnings;
use Email::MIME;

use 5.010;             # because \K
no warnings 'utf8';    # assume it's ok to dump decoded characters to STDOUT

my %pattern = (    # ways to pick an address and a pattern
    wide => [
        [ 'list-id', qr/(<.*>)/, '~hlist-id:.*%s' ],
        [ 'from',    qr/<(.*)>/, '~f%s|~C%s' ],
        [ 'from',    qr/(.*)/,   '~f%s|~C%s' ],        # fallback
    ],
    narrow => [
        [ 'subject', qr/^\s*(?:(?:Re:|Fwd:|\[.*?\])\s*)*\K(.*)/i, '~s\\"%s\\"' ],
    ],
    thread => [
        [ 'message-id', qr/(<.*>)/, '~hreferences:.*%s|~hmessage-id:.*%s' ],
    ],
);

# pick up command and pattern
my $cmd = shift || 'limit';
my $pat = shift || 'wide';

die "Unknown pattern type `$pat`\n" if !exists $pattern{$pat};
my @patterns = @{ $pattern{$pat} };

# create email from STDIN
my $email = Email::MIME->new( do { local $/; <>; } );

# pick up the address
my ( $addr, $fmt );
for (@patterns) {
    ( my $header, my $re, $fmt ) = @$_;
    ($addr) = ( lc $email->header($header) || '' ) =~ $re;
    last if $addr;
}

# spit out the requested Mutt command
if ($addr) {
    $addr =~ s/([](.+)[])/\\\\\\\\$1/g;    # escape what needs to be
    $addr =~ s/ +/.*/g;
    my $expr = sprintf $fmt, ($addr) x ( $fmt =~ y/%// );
    printf qq{"\\<$cmd\\>%s\\<enter\\>"}, $expr;
}

__END__

# Usage:

# pick up a temporary file when starting Mutt
set my_tmp_mutt=`mktemp --tmpdir mutt-XXXXXXXX`

# apply to wide selection
macro index ,l "<enter-command> set my_wait_key=$wait_key<enter>\
<enter-command> set wait_key=no<enter>\
<pipe-message>mutt-cmd-gen limit wide > $my_tmp_mutt<enter>\
<enter-command> push \`cat $my_tmp_mutt\`<enter>\
<enter-command> set wait_key=\$my_wait_key<enter>" "Magically limit to all related messages (wide)"

macro index ,t "<enter-command> set my_wait_key=$wait_key<enter>\
<enter-command> unset wait_key<enter>\
<pipe-message>mutt-cmd-gen tag-pattern wide > $my_tmp_mutt<enter>\
<enter-command> push \`cat $my_tmp_mutt\`<enter>\
<enter-command> set wait_key=\$my_wait_key<enter>" "Magically tag all related messages (wide)"

# apply to narrow selection
macro index ,L "<enter-command> set my_wait_key=$wait_key<enter>\
<enter-command> set wait_key=no<enter>\
<pipe-message>mutt-cmd-gen limit narrow > $my_tmp_mutt<enter>\
<enter-command> push \`cat $my_tmp_mutt\`<enter>\
<enter-command> set wait_key=\$my_wait_key<enter>" "Magically limit to all related messages (narrow)"

macro index ,T "<enter-command> set my_wait_key=$wait_key<enter>\
<enter-command> set wait_key=no<enter>\
<pipe-message>mutt-cmd-gen tag-pattern narrow > $my_tmp_mutt<enter>\
<enter-command> push \`cat $my_tmp_mutt\`<enter>\
<enter-command> set wait_key=\$my_wait_key<enter>" "Magically tag all related messages (narrow)"
